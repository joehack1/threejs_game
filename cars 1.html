<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Car Racing Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #score {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-size: 26px;
      font-family: Arial;
      z-index: 10;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      font-family: Arial;
    }
  </style>
</head>
<body>
<div id="score">Score: 0</div>
<div id="loading">Loading 3D Models...</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.min.js"></script>
<!-- THREE.js Loaders for 3D models -->
<script src="https://cdn.jsdelivr.net/npm/three@0.156.1/examples/js/loaders/GLTFLoader.js"></script>

<script>
/* ------------------------------------------------------------------
   SCENE + CAMERA + RENDERER
------------------------------------------------------------------ */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x111111, 10, 100);

const camera = new THREE.PerspectiveCamera(
  70,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 8, 15);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

/* ------------------------------------------------------------------
   LOADING MANAGER
------------------------------------------------------------------ */
const loadingManager = new THREE.LoadingManager();
loadingManager.onLoad = () => {
  document.getElementById('loading').style.display = 'none';
};

const gltfLoader = new THREE.GLTFLoader(loadingManager);

/* ------------------------------------------------------------------
   ROAD CREATION
------------------------------------------------------------------ */
function createRoad() {
  // Road surface
  const roadGeometry = new THREE.PlaneGeometry(8, 200);
  const roadMaterial = new THREE.MeshPhongMaterial({ 
    color: 0x333333,
    side: THREE.DoubleSide
  });
  const road = new THREE.Mesh(roadGeometry, roadMaterial);
  road.rotation.x = -Math.PI / 2;
  road.receiveShadow = true;
  road.position.z = -100;
  scene.add(road);

  // Road markings
  for (let i = -100; i < 100; i += 4) {
    const markingGeometry = new THREE.PlaneGeometry(0.3, 1.5);
    const markingMaterial = new THREE.MeshPhongMaterial({ 
      color: 0xffff00,
      side: THREE.DoubleSide
    });
    const marking = new THREE.Mesh(markingGeometry, markingMaterial);
    marking.rotation.x = -Math.PI / 2;
    marking.position.set(0, 0.01, i);
    scene.add(marking);
  }

  // Road borders
  const borderGeometry = new THREE.BoxGeometry(0.5, 0.3, 200);
  const borderMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
  
  const leftBorder = new THREE.Mesh(borderGeometry, borderMaterial);
  leftBorder.position.set(-4.25, 0.15, -100);
  leftBorder.castShadow = true;
  leftBorder.receiveShadow = true;
  scene.add(leftBorder);
  
  const rightBorder = new THREE.Mesh(borderGeometry, borderMaterial);
  rightBorder.position.set(4.25, 0.15, -100);
  rightBorder.castShadow = true;
  rightBorder.receiveShadow = true;
  scene.add(rightBorder);

  return road;
}

const road = createRoad();

/* ------------------------------------------------------------------
   LIGHTING
------------------------------------------------------------------ */
const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(0, 20, 10);
directionalLight.castShadow = true;
directionalLight.shadow.camera.left = -20;
directionalLight.shadow.camera.right = 20;
directionalLight.shadow.camera.top = 20;
directionalLight.shadow.camera.bottom = -20;
scene.add(directionalLight);

/* ------------------------------------------------------------------
   PLAYER CAR (3D Model)
------------------------------------------------------------------ */
let playerCar = null;
const playerCarUrl = 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r156/examples/models/gltf/ferrari.glb';

gltfLoader.load(playerCarUrl, (gltf) => {
  playerCar = gltf.scene;
  playerCar.scale.set(0.5, 0.5, 0.5);
  playerCar.position.set(0, 0.5, 0);
  
  // Enable shadows for all children
  playerCar.traverse((child) => {
    if (child.isMesh) {
      child.castShadow = true;
      child.receiveShadow = true;
    }
  });
  
  scene.add(playerCar);
}, undefined, (error) => {
  console.error('Failed to load player car, using fallback:', error);
  // Fallback: Simple car
  const carGeo = new THREE.BoxGeometry(1, 0.5, 2);
  const carMat = new THREE.MeshPhongMaterial({ color: 0x00aaff });
  playerCar = new THREE.Mesh(carGeo, carMat);
  playerCar.position.y = 0.25;
  playerCar.castShadow = true;
  scene.add(playerCar);
});

/* ------------------------------------------------------------------
   OBSTACLE CARS (3D Models)
------------------------------------------------------------------ */
let obstacles = [];
const obstacleCarUrl = 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r156/examples/models/gltf/sportsCar.glb';

function spawnObstacleCar() {
  gltfLoader.load(obstacleCarUrl, (gltf) => {
    const obstacle = gltf.scene;
    obstacle.scale.set(0.4, 0.4, 0.4);
    
    // Random lane position (-3, 0, 3)
    const lanes = [-3, 0, 3];
    obstacle.position.x = lanes[Math.floor(Math.random() * lanes.length)];
    obstacle.position.y = 0.2;
    obstacle.position.z = -20;
    
    // Random color
    obstacle.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true;
        if (child.material) {
          child.material.color.setHex(Math.random() * 0xffffff);
        }
      }
    });
    
    scene.add(obstacle);
    obstacles.push({
      mesh: obstacle,
      speed: 0.08 + Math.random() * 0.04
    });
  }, undefined, (error) => {
    console.error('Failed to load obstacle car:', error);
    // Fallback: Simple cube
    const carGeo = new THREE.BoxGeometry(1, 0.5, 2);
    const carMat = new THREE.MeshPhongMaterial({ 
      color: Math.random() * 0xffffff 
    });
    const obstacle = new THREE.Mesh(carGeo, carMat);
    const lanes = [-3, 0, 3];
    obstacle.position.x = lanes[Math.floor(Math.random() * lanes.length)];
    obstacle.position.y = 0.25;
    obstacle.position.z = -20;
    obstacle.castShadow = true;
    scene.add(obstacle);
    obstacles.push({
      mesh: obstacle,
      speed: 0.08 + Math.random() * 0.04
    });
  });
}

setInterval(spawnObstacleCar, 1200);

/* ------------------------------------------------------------------
   INPUT HANDLING
------------------------------------------------------------------ */
const keys = {};
document.addEventListener("keydown", (e) => keys[e.key] = true);
document.addEventListener("keyup", (e) => keys[e.key] = false);

/* ------------------------------------------------------------------
   COLLISION CHECK
------------------------------------------------------------------ */
function collides(a, b) {
  const aBox = new THREE.Box3().setFromObject(a);
  const bBox = new THREE.Box3().setFromObject(b);
  return aBox.intersectsBox(bBox);
}

/* ------------------------------------------------------------------
   GAME VARIABLES
------------------------------------------------------------------ */
let score = 0;
let gameSpeed = 0.1;
let playerLane = 0; // -1: left, 0: center, 1: right
const lanePositions = [-3, 0, 3];
let targetX = 0;

/* ------------------------------------------------------------------
   GAME LOOP
------------------------------------------------------------------ */
function animate() {
  requestAnimationFrame(animate);

  // Handle input
  if (keys["ArrowLeft"] && playerLane > -1) {
    playerLane--;
    keys["ArrowLeft"] = false; // Prevent holding
  }
  if (keys["ArrowRight"] && playerLane < 1) {
    playerLane++;
    keys["ArrowRight"] = false;
  }

  // Smooth lane transition
  targetX = lanePositions[playerLane + 1];
  if (playerCar) {
    playerCar.position.x += (targetX - playerCar.position.x) * 0.2;
  }

  // Move obstacles
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const obstacle = obstacles[i];
    obstacle.mesh.position.z += obstacle.speed + gameSpeed * 0.01;
    
    // Check collision
    if (playerCar && collides(playerCar, obstacle.mesh)) {
      alert("CRASH! Game Over\nScore: " + score);
      location.reload();
    }
    
    // Remove passed cars and increase score
    if (obstacle.mesh.position.z > 15) {
      scene.remove(obstacle.mesh);
      obstacles.splice(i, 1);
      score += 10;
      document.getElementById("score").innerText = "Score: " + score;
      gameSpeed += 0.005; // Increase difficulty
    }
  }

  // Move road (illusion of movement)
  road.position.z += gameSpeed;
  if (road.position.z > 0) {
    road.position.z = -100;
  }

  // Animate player car (bouncing effect)
  if (playerCar) {
    playerCar.position.y = 0.5 + Math.sin(Date.now() * 0.005) * 0.05;
  }

  renderer.render(scene, camera);
}

// Start animation after a short delay to ensure models load
setTimeout(animate, 1000);

/* ------------------------------------------------------------------
   RESIZE
------------------------------------------------------------------ */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ------------------------------------------------------------------
   ENVIRONMENT (Optional decoration)
------------------------------------------------------------------ */
// Add some trees/buildings
for (let i = 0; i < 20; i++) {
  const treeGeo = new THREE.ConeGeometry(0.5, 2, 8);
  const treeMat = new THREE.MeshPhongMaterial({ color: 0x00aa00 });
  const tree = new THREE.Mesh(treeGeo, treeMat);
  tree.position.set(
    Math.random() > 0.5 ? -8 : 8,
    1,
    -Math.random() * 200
  );
  tree.castShadow = true;
  scene.add(tree);
}
</script>

</body>
</html>